<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Simulatore Ferroviario Centro-Sud</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body, html { margin: 0; padding: 0; height: 100%; font-family: 'Segoe UI', sans-serif; }
        #map { height: 100vh; width: 100%; background: #1a1a1a; }
        
        .ui-panel {
            position: absolute; top: 15px; left: 15px; z-index: 1000;
            background: rgba(255, 255, 255, 0.9); padding: 20px; border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); width: 300px;
        }
        .clock { font-size: 32px; font-weight: bold; color: #2c3e50; font-family: monospace; display: block; text-align: center; }
        .controls { margin-top: 15px; display: flex; flex-direction: column; gap: 10px; }
        .status-box { margin-top: 10px; font-size: 12px; color: #555; border-top: 1px solid #ccc; padding-top: 5px; }
        input[type="time"] { width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #ddd; }
        button { padding: 10px; cursor: pointer; background: #3498db; color: white; border: none; border-radius: 5px; font-weight: bold; }
        button:hover { background: #2980b9; }
    </style>
</head>
<body>

<div class="ui-panel">
    <span class="clock" id="txt-ora">12:00:00</span>
    <div class="controls">
        <input type="time" id="input-ora" step="1" onchange="impostaOra()">
        <button onclick="resetTempo()">TORNA AL PRESENTE</button>
    </div>
    <div id="status" class="status-box">Caricamento file GeoJSON...</div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/bbecquet/Leaflet.RotatedMarker/leaflet.rotatedMarker.js"></script>

<script>
    // --- 1. CONFIGURAZIONE FILE ---
    const FILE_BINARI = ['binari_lazio.geojson', 'binari_campania.geojson'];
    const FILE_STAZIONI = ['stazioni_lazio.geojson', 'stazioni_campania.geojson'];
    const FILE_TRENI = 'database_treni.json';

    // --- 2. INIZIALIZZAZIONE MAPPA ---
    const map = L.map('map', { zoomControl: false }).setView([41.5, 13.5], 8);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png').addTo(map);

    let virtualTime = new Date();
    const pulisciNome = (n) => n.toString().toLowerCase().trim().replace(/\s+/g, ' ');

    // --- 3. CARICAMENTO MULTI-FILE ---
    async function init() {
        try {
            // Carichiamo tutti i file in parallelo
            const fetchBinari = FILE_BINARI.map(f => fetch(f).then(res => res.json()));
            const fetchStazioni = FILE_STAZIONI.map(f => fetch(f).then(res => res.json()));
            const fetchTreni = fetch(FILE_TRENI).then(res => res.json());

            const [dataBinari, dataStazioni, treniDB] = await Promise.all([
                Promise.all(fetchBinari),
                Promise.all(fetchStazioni),
                fetchTreni
            ]);

            // Uniamo i binari in un'unica collezione
            const reteUnificata = {
                type: "FeatureCollection",
                features: dataBinari.flatMap(g => g.features)
            };

            // Uniamo le stazioni
            const stazioniUnificate = {
                type: "FeatureCollection",
                features: dataStazioni.flatMap(g => g.features)
            };

            document.getElementById('status').innerText = "Rete caricata. Simulazione attiva.";

            // Disegniamo la rete sulla mappa
            L.geoJSON(reteUnificata, { 
                style: { color: '#444', weight: 1.5, opacity: 0.6 } 
            }).addTo(map);

            // Avviamo ogni treno
            treniDB.forEach(treno => {
                const tracciato = reteUnificata.features.find(f => 
                    pulisciNome(f.properties.name || "") === pulisciNome(treno.linea)
                );
                if (tracciato) {
                    avviaSimulazioneTreno(tracciato, treno, stazioniUnificate);
                } else {
                    console.warn(`Binari non trovati per: ${treno.linea}`);
                }
            });

        } catch (err) {
            document.getElementById('status').innerHTML = "<span style='color:red'>Errore caricamento file! Controlla i nomi.</span>";
            console.error(err);
        }
    }

    // --- 4. MOTORE DI MOVIMENTO ---
    function avviaSimulazioneTreno(lineaGeo, dati, stazioniGeo) {
        const icona = L.icon({ 
            iconUrl: 'https://cdn-icons-png.flaticon.com/512/725/725304.png', 
            iconSize: [22, 22] 
        });
        const marker = L.marker([0, 0], { icon: icona, rotationAngle: 0 }).addTo(map);
        marker.bindPopup(`<b>${dati.nome}</b><br>Linea: ${dati.linea}`);

        setInterval(() => {
            const oraAttuale = virtualTime.getHours() * 3600 + virtualTime.getMinutes() * 60 + virtualTime.getSeconds();
            let posPunto = null;
            let angolo = 0;

            for (let i = 0; i < dati.fermate.length - 1; i++) {
                const f1 = dati.fermate[i];
                const f2 = dati.fermate[i+1];

                const s1 = stazioniGeo.features.find(s => pulisciNome(s.properties.name) === pulisciNome(f1.stazione));
                const s2 = stazioniGeo.features.find(s => pulisciNome(s.properties.name) === pulisciNome(f2.stazione));

                if (s1 && s2) {
                    const t_partenza = convertiInSecondi(f1.part);
                    const t_arrivo_succ = convertiInSecondi(f2.arr);

                    if (oraAttuale >= t_partenza && oraAttuale <= t_arrivo_succ) {
                        const d1 = turf.nearestPointOnLine(lineaGeo, s1).properties.location;
                        const d2 = turf.nearestPointOnLine(lineaGeo, s2).properties.location;

                        const progresso = (oraAttuale - t_partenza) / (t_arrivo_succ - t_partenza);
                        const distanzaAttuale = d1 + (d2 - d1) * progresso;

                        posPunto = turf.along(lineaGeo, distanzaAttuale);
                        const prossimoPunto = turf.along(lineaGeo, distanzaAttuale + 0.05);
                        angolo = turf.bearing(posPunto, prossimoPunto);
                        break;
                    }
                }
            }

            if (posPunto) {
                marker.setOpacity(1);
                const coords = posPunto.geometry.coordinates;
                marker.setLatLng([coords[1], coords[0]]);
                marker.setRotationAngle(angolo + 90);
            } else {
                marker.setOpacity(0);
            }
        }, 1000);
    }

    // --- 5. UTILITY TEMPO ---
    function convertiInSecondi(hms) {
        const p = hms.split(':');
        return (+p[0]) * 3600 + (+p[1]) * 60 + (+p[2] || 0);
